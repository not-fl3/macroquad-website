<!DOCTYPE html>
<html lang="en-US">
<head>
<meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" as="font" href="https://macroquad.rs/fonts/vendor/jost/jost-v4-latin-regular.woff2" type="font/woff2" crossorigin>
  <link rel="preload" as="font" href="https://macroquad.rs/fonts/vendor/jost/jost-v4-latin-700.woff2"  type="font/woff2" crossorigin>


  <link rel="stylesheet" type="text/css" href="https://macroquad.rs/semantic.min.css">
  <link rel="stylesheet" type="text/css" href="https://macroquad.rs/fonts.css">

  <style>
    .ui, h1, h2, h3, h4, h5 {
        font-family: "Jost",-apple-system,blinkmacsystemfont,"Segoe UI",roboto,"Helvetica Neue",arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji" !important;
    }
    .zola-anchor {
        font-size: 1.25rem;
        margin-left: -2rem;
        margin-right: 0.75rem;
        text-decoration: none;
        border-bottom-color: transparent;
        cursor: pointer;
      }
  </style>
  <script
    src="https://macroquad.rs/jquery-3.1.1.min.js"
    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
    crossorigin="anonymous"></script>
  <script src="https://macroquad.rs/semantic.min.js"></script>



  
    
  



  <meta name="theme-color" content="#fff">
  <link rel="apple-touch-icon" sizes="180x180" href="https://macroquad.rs/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://macroquad.rs/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://macroquad.rs/favicon-16x16.png">
  
    <link rel="manifest" href="https://macroquad.rs/site.webmanifest">
  

</head>

<body class="home">
  
    
<div class="ui borderless huge menu">
  <a class=

"item active"

 href="/">
    Macroquad
  </a>
  <a class=

"item"

  href="/examples">
    Examples
  </a>
  <a class=

"item"

 href="/articles">
    Articles
  </a>
  <a class=

"item"

 href="/docs">
    docs.rs
  </a>
  

    <a href="https://github.com/not-fl3/macroquad" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
</div>

<script type="text/javascript">
$(document).ready(function(){
    $(document).on('click','.item',function(e){
        $('.ui .item').removeClass('active');
        $(this).addClass('active');
});
});
</script>


  

  
<style type="text/css">
  .eleven.wide.column {
      font-size: 18px;
  }
  pre,
  code,
  kbd,
  samp {
      font-family: $font-family-monospace;
      font-size: $font-size-sm;
      border-radius: $border-radius;
  }
  
  code {
      background: #f7f7f7;
      //color: $black;
      padding: 0.25rem 0.5rem;
  }
  
  pre {
      margin: 2rem 0;
  }
  
  pre code {
      display: block;
      overflow-x: auto;
      line-height: $line-height-base;
      padding: 1.25rem 1.5rem;
      tab-size: 4;
      scrollbar-width: thin;
      scrollbar-color: transparent transparent;
  }
</style>

<div class="ui grid stackable container">
  <div class="row" id="article">
    <div class="eleven wide centered column">
      <h2 class="ui large header">
        <div class="content">Making an online multiplayer game in Rust with Nakama</div>
      </h2>
      <div class="ui hidden divider"></div>
      <img src="/fishgame_tutorial/title.gif"  width="100%"/>
<p>Fish Game is a 2-4 player online game built in the <a href="https://github.com/not-fl3/macroquad/">Macroquad</a> game engine and the <a href="https://www.rust-lang.org/">Rust</a> programming language. The game was created as a demonstration of <a href="https://heroiclabs.com/">Nakama</a>, an open-source scalable game server.</p>
<p>As you can see, Fish Game is a frenetic platformer arena starring murderous fish - the last fish standing wins! The game design is heavily inspired by the excellent <a href="https://store.steampowered.com/app/312530/Duck_Game/">Duck Game</a>.</p>
<p>The game is playable <a href="https://fedorgames.itch.io/fish-game?secret=UAVcggHn332a">online on itch.io</a> and the Windows/Linux/Mac native version may be built from <a href="https://github.com/heroiclabs/fishgame-macroquad">the source</a>.</p>
<p>In this tutorial, weâ€™re going to walk through each part of the code that interacts with Nakama to cover all the principles and APIs that you need to know to create your own online multiplayer game with Macroquad and Nakama.</p>
<p>Weâ€™ll touch on the following Nakama features:</p>
<ul>
<li>User authentication</li>
<li>Matchmaking</li>
<li>Realtime Multiplayer</li>
<li>Leaderboards</li>
</ul>
<p>This tutorial will briefly cover how to create a game with Macroquad. Afterward, it will focus on Nakama integration.</p>
<h1 id="making-a-platformer-game"><a class="zola-anchor" href="#making-a-platformer-game" aria-label="Anchor link for: making-a-platformer-game">ðŸ”—</a>Making a platformer game</h1>
<p>This part of the tutorial will explain how to create a single-player platformer game in Rust, starting with setting up macroquad. By the end of this section, we will have created a simple but fully functional platformer.</p>
<h2 id="setting-up-macroquad"><a class="zola-anchor" href="#setting-up-macroquad" aria-label="Anchor link for: setting-up-macroquad">ðŸ”—</a>Setting up macroquad</h2>
<p>Start an empty Rust project:</p>
<pre data-lang="bash" style="background-color:#ffffff;color:#323232;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> cargo init --bin fishgame
</span></code></pre>
<p>Run it: </p>
<pre data-lang="bash" style="background-color:#ffffff;color:#323232;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> cd fishgame
</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span> cargo run 
</span><span>     Running `target/debug/fishgame`
</span><span>Hello, world!
</span></code></pre>
<p>Open <code>Cargo.toml</code> and add macroquad as a dependency:</p>
<pre data-lang="toml" style="background-color:#ffffff;color:#323232;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[package]
</span><span style="color:#63a35c;">name </span><span>= </span><span style="color:#183691;">&quot;fishgame&quot;
</span><span style="background-color:#f5f5f5;font-weight:bold;color:#b52a1d;">...</span><span>
</span><span>
</span><span>[dependencies]
</span><span style="color:#63a35c;">macroquad </span><span>= </span><span style="color:#183691;">&quot;0.3&quot;
</span></code></pre>
<p>Open <code>src/main.rs</code> and add some macroquad drawing code to check that everything works (took this from <a href="https://github.com/not-fl3/macroquad/tree/master/examples">macroquad examples</a>):</p>
<p><code>src/main.rs</code>:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">use </span><span>macroquad::prelude::</span><span style="font-weight:bold;color:#a71d5d;">*</span><span>;
</span><span>
</span><span>#[macroquad::main(</span><span style="color:#183691;">&quot;BasicShapes&quot;</span><span>)]
</span><span>async </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span>() {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>        </span><span style="color:#62a35c;">clear_background</span><span>(</span><span style="color:#0086b3;">RED</span><span>);
</span><span>
</span><span>        </span><span style="color:#62a35c;">draw_line</span><span>(</span><span style="color:#0086b3;">40.0</span><span>, </span><span style="color:#0086b3;">40.0</span><span>, </span><span style="color:#0086b3;">100.0</span><span>, </span><span style="color:#0086b3;">200.0</span><span>, </span><span style="color:#0086b3;">15.0</span><span>, </span><span style="color:#0086b3;">BLUE</span><span>);
</span><span>        </span><span style="color:#62a35c;">draw_rectangle</span><span>(</span><span style="color:#62a35c;">screen_width</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">/ </span><span style="color:#0086b3;">2.0 </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">60.0</span><span>, </span><span style="color:#0086b3;">100.0</span><span>, </span><span style="color:#0086b3;">120.0</span><span>, </span><span style="color:#0086b3;">60.0</span><span>, </span><span style="color:#0086b3;">GREEN</span><span>);
</span><span>        </span><span style="color:#62a35c;">draw_circle</span><span>(</span><span style="color:#62a35c;">screen_width</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">30.0</span><span>, </span><span style="color:#62a35c;">screen_height</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">30.0</span><span>, </span><span style="color:#0086b3;">15.0</span><span>, </span><span style="color:#0086b3;">YELLOW</span><span>);
</span><span>
</span><span>        </span><span style="color:#62a35c;">draw_text</span><span>(</span><span style="color:#183691;">&quot;IT WORKS!&quot;</span><span>, </span><span style="color:#0086b3;">20.0</span><span>, </span><span style="color:#0086b3;">20.0</span><span>, </span><span style="color:#0086b3;">30.0</span><span>, </span><span style="color:#0086b3;">DARKGRAY</span><span>);
</span><span>
</span><span>        </span><span style="color:#62a35c;">next_frame</span><span>().await
</span><span>    }
</span><span>}
</span></code></pre>
<pre style="background-color:#ffffff;color:#323232;"><code><span>&gt; cargo run
</span></code></pre>
<img src="/fishgame_tutorial/itworks.png"  width="100%"/>
<p>If we got a window with some shapes: All good, the project is set up correctly. Now it's time to draw more shapes to make it look like a game.</p>
<p>If instead of a window, we have some errors: Maybe some native dependency is missing. Most likely, it is one of these: </p>
<pre data-lang="bash" style="background-color:#ffffff;color:#323232;" class="language-bash "><code class="language-bash" data-lang="bash"><span>apt install libx11-dev libxi-dev libgl1-mesa-dev
</span></code></pre>
<p>For more details, check the <a href="https://github.com/not-fl3/macroquad/#building-instructions">build instructions</a>.</p>
<h2 id="making-game-levels"><a class="zola-anchor" href="#making-game-levels" aria-label="Anchor link for: making-game-levels">ðŸ”—</a>Making game levels</h2>
<p>The easiest way to do some 2D-level design with macroquad is with the free tiles editor <a href="https://www.mapeditor.org">Tiled</a>.</p>
<img src="/fishgame_tutorial/tiled.png"  width="100%"/>
<p><em>Tiled with <a href="https://github.com/heroiclabs/fishgame-macroquad/blob/master/assets/map.json">Fish Game's level</a></em></p>
<p>We have a <a href="https://crates.io/crates/macroquad-tiled">crate</a> for reading tiled data in macroquad. 
<code>our Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#ffffff;color:#323232;" class="language-toml "><code class="language-toml" data-lang="toml"><span style="background-color:#f5f5f5;font-weight:bold;color:#b52a1d;">...</span><span>
</span><span>[dependencies]
</span><span style="color:#63a35c;">macroquad </span><span>= </span><span style="color:#183691;">&quot;0.3&quot;
</span><span style="font-style:italic;color:#969896;"># the new dependency, macroquad-tiled crate:
</span><span style="color:#63a35c;">macroquad-tiled </span><span>= </span><span style="color:#183691;">&quot;0.1&quot;
</span></code></pre>
<p>Then load the Tiled map to macroquad and draw a level:</p>
<p><code>src/main.rs</code>, all assets are in <a href="https://github.com/heroiclabs/fishgame-macroquad/tree/master/assets">the Fish Game repo</a>:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">use </span><span>macroquad::prelude::</span><span style="font-weight:bold;color:#a71d5d;">*</span><span>;
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">use</span><span> macroquad_tiled </span><span style="font-weight:bold;color:#a71d5d;">as</span><span> tiled;
</span><span>
</span><span>#[macroquad::main(</span><span style="color:#183691;">&quot;Fishgame&quot;</span><span>)]
</span><span>async </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span>() {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> tileset </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">load_texture</span><span>(</span><span style="color:#183691;">&quot;assets/tileset.png&quot;</span><span>).await;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> decorations </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">load_texture</span><span>(</span><span style="color:#183691;">&quot;assets/decorations1.png&quot;</span><span>).await;
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> tiled_map_json </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">load_string</span><span>(</span><span style="color:#183691;">&quot;assets/map.json&quot;</span><span>).await.</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> tiled_map </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>tiled::load_map(
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>tiled_map_json,
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>[(</span><span style="color:#183691;">&quot;tileset.png&quot;</span><span>, tileset), (</span><span style="color:#183691;">&quot;decorations1.png&quot;</span><span>, decorations)],
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>[],
</span><span>    )
</span><span>    .</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>        </span><span style="color:#62a35c;">clear_background</span><span>(</span><span style="color:#0086b3;">BLACK</span><span>);
</span><span>        tiled_map.</span><span style="color:#62a35c;">draw_tiles</span><span>(
</span><span>            </span><span style="font-style:italic;color:#969896;">// The name of the layer in assets/map.json
</span><span>            </span><span style="color:#183691;">&quot;main layer&quot;</span><span>,
</span><span>            Rect::new(</span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#62a35c;">screen_width</span><span>(), </span><span style="color:#62a35c;">screen_height</span><span>()),
</span><span>            </span><span style="color:#0086b3;">None</span><span>,
</span><span>        );
</span><span>        </span><span style="color:#62a35c;">next_frame</span><span>().await;
</span><span>    }
</span><span>}
</span></code></pre>
<img src="/fishgame_tutorial/background.png"  width="100%"/>
<p>Now we have a level background. For a more polished game, it would be reasonable to invest some time into a more complicated camera, window handling, etc.
All of those are implemented in the final Fish Game but will be skipped in the tutorial to get started with Nakama faster.</p>
<h2 id="character-physics"><a class="zola-anchor" href="#character-physics" aria-label="Anchor link for: character-physics">ðŸ”—</a>Character physics</h2>
<p>Add a character into the level from the previous chapter:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">...
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> whale </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">load_texture</span><span>(</span><span style="color:#183691;">&quot;assets/Whale/Whale(76x66)(Orange).png&quot;</span><span>).await;
</span><span>
</span><span style="font-style:italic;color:#969896;">// for simplicity lets give our world fixed size
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> width </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">700.</span><span>;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> height </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">500.</span><span>;
</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>    tiled_map.</span><span style="color:#62a35c;">draw_tiles</span><span>(
</span><span>        </span><span style="font-style:italic;color:#969896;">// The name of the layer in assets/map.json
</span><span>        </span><span style="color:#183691;">&quot;main layer&quot;</span><span>,
</span><span>        Rect::new(</span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#0086b3;">0.0</span><span>, width, height),
</span><span>        </span><span style="color:#0086b3;">None</span><span>,
</span><span>    );
</span><span>
</span><span>    </span><span style="color:#62a35c;">draw_texture_ex</span><span>(
</span><span>        whale,
</span><span>        </span><span style="color:#0086b3;">0.</span><span>,
</span><span>        </span><span style="color:#0086b3;">0.</span><span>,
</span><span>        </span><span style="color:#0086b3;">WHITE</span><span>,
</span><span>        DrawTextureParams {
</span><span>            source: </span><span style="color:#0086b3;">Some</span><span>(Rect::new(</span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#0086b3;">76.</span><span>, </span><span style="color:#0086b3;">66.</span><span>)),
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">Default</span><span>::default()
</span><span>        },
</span><span>    );
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>}
</span></code></pre>
<img src="/fishgame_tutorial/character.png"  width="100%"/>
<p>Now we have a character and a level. The next step is to allow the user to move the character.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> fish_pos </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">vec2</span><span>(</span><span style="color:#0086b3;">200.</span><span>, </span><span style="color:#0086b3;">100.</span><span>);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">is_key_down</span><span>(KeyCode::Right) {
</span><span>        fish_pos.x </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1.0</span><span>;
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">is_key_down</span><span>(KeyCode::Left) {
</span><span>        fish_pos.x </span><span style="font-weight:bold;color:#a71d5d;">-= </span><span style="color:#0086b3;">1.0</span><span>;
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> fish_bottom_point </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">vec2</span><span>(fish_pos.x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">76. </span><span style="font-weight:bold;color:#a71d5d;">/ </span><span style="color:#0086b3;">2.</span><span>, fish_pos.y </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">66.</span><span>);
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> fish_tile </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">vec2</span><span>(
</span><span>        fish_bottom_point.x </span><span style="font-weight:bold;color:#a71d5d;">/</span><span> width </span><span style="font-weight:bold;color:#a71d5d;">*</span><span> tiled_map.raw_tiled_map.width </span><span style="font-weight:bold;color:#a71d5d;">as f32</span><span>,
</span><span>        fish_bottom_point.y </span><span style="font-weight:bold;color:#a71d5d;">/</span><span> height </span><span style="font-weight:bold;color:#a71d5d;">*</span><span> tiled_map.raw_tiled_map.height </span><span style="font-weight:bold;color:#a71d5d;">as f32</span><span>,
</span><span>    );
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> tiled_map
</span><span>        .</span><span style="color:#62a35c;">get_tile</span><span>(</span><span style="color:#183691;">&quot;main layer&quot;</span><span>, fish_tile.x </span><span style="font-weight:bold;color:#a71d5d;">as u32</span><span>, fish_tile.y </span><span style="font-weight:bold;color:#a71d5d;">as u32</span><span>)
</span><span>        .</span><span style="color:#62a35c;">is_none</span><span>()
</span><span>    {
</span><span>        fish_pos.y </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">2.0</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<img src="/fishgame_tutorial/character_moving.gif"  width="100%"/>
<p>There are lots hard-coded corner cases to take into account, but putting all of this together gives us a complete platformer character mechanic.</p>
<p>There is a crate with platformer physics implementation based on the brilliant <a href="https://maddythorson.medium.com/celeste-and-towerfall-physics-d24bd2ae0fc5">article on Celeste and Towerfall physics</a>: <a href="https://crates.io/crates/macroquad-platformer">macroquad-platformer</a>.</p>
<p><code>Cargo.toml</code>:</p>
<pre data-lang="toml" style="background-color:#ffffff;color:#323232;" class="language-toml "><code class="language-toml" data-lang="toml"><span>[dependencies]
</span><span style="color:#63a35c;">macroquad </span><span>= </span><span style="color:#183691;">&quot;0.3&quot;
</span><span style="color:#63a35c;">macroquad-tiled </span><span>= </span><span style="color:#183691;">&quot;0.1&quot;
</span><span style="color:#63a35c;">macroquad-platformer </span><span>= </span><span style="color:#183691;">&quot;0.1&quot;
</span></code></pre>
<p>With the new crate involved, the code will look like the <a href="https://github.com/not-fl3/macroquad/blob/master/examples/platformer.rs">platformer example</a>. </p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> world </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>World::new();
</span><span>world.</span><span style="color:#62a35c;">add_static_tiled_layer</span><span>(
</span><span>    static_colliders,
</span><span>    tiled_map.raw_tiled_map.tilewidth </span><span style="font-weight:bold;color:#a71d5d;">as f32</span><span>,
</span><span>    tiled_map.raw_tiled_map.tileheight </span><span style="font-weight:bold;color:#a71d5d;">as f32</span><span>,
</span><span>    tiled_map.raw_tiled_map.width </span><span style="font-weight:bold;color:#a71d5d;">as _</span><span>,
</span><span>    </span><span style="color:#0086b3;">1</span><span>,
</span><span>);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> player </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> world.</span><span style="color:#62a35c;">add_actor</span><span>(</span><span style="color:#62a35c;">vec2</span><span>(</span><span style="color:#0086b3;">200.0</span><span>, </span><span style="color:#0086b3;">100.0</span><span>), </span><span style="color:#0086b3;">36</span><span>, </span><span style="color:#0086b3;">66</span><span>);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>    </span><span style="font-style:italic;color:#969896;">// now instead of moving player directly
</span><span>    </span><span style="font-style:italic;color:#969896;">// we do it through a crate
</span><span>    world.</span><span style="color:#62a35c;">move_h</span><span>(player, speed.x </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#62a35c;">get_frame_time</span><span>());
</span><span>    world.</span><span style="color:#62a35c;">move_v</span><span>(player, speed.y </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#62a35c;">get_frame_time</span><span>());
</span><span>
</span><span>    </span><span style="font-style:italic;color:#969896;">// and to draw the player we ask the crate for the player&#39;s current position:
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> pos </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> world.</span><span style="color:#62a35c;">actor_pos</span><span>(player.collider);
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>}
</span></code></pre>
<p><a href="https://gist.github.com/not-fl3/a51dbff5f09c04d5a371e55db4c48e13">Full source code</a></p>
<p>Now the fish can jump!</p>
<img src="/fishgame_tutorial/fish_jump.gif"  width="100%"/>
<h2 id="nodes"><a class="zola-anchor" href="#nodes" aria-label="Anchor link for: nodes">ðŸ”—</a>Nodes</h2>
<p>Now we have enough of a game to start adding Nakama networking. Just one final piece missing.</p>
<p>So far, the game code looks like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>async </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span>() {
</span><span>   </span><span style="font-style:italic;color:#969896;">// load some resources
</span><span>   </span><span style="font-style:italic;color:#969896;">// and initialize more variables
</span><span>   </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>       </span><span style="font-style:italic;color:#969896;">// check input and change some variables
</span><span>       </span><span style="font-style:italic;color:#969896;">// make a few draw calls based on the variables content
</span><span>       
</span><span>       </span><span style="font-style:italic;color:#969896;">// and repeat this forever
</span><span>       </span><span style="color:#62a35c;">next_frame</span><span>().await;
</span><span>   }
</span><span>}
</span></code></pre>
<p>This may be good enough for a quick prototype. But for the whole Fish Game, we are going to have quite a few things in those variables:</p>
<ul>
<li>other players</li>
<li>weapons</li>
<li>bullets</li>
<li>level decorations</li>
<li>some UI</li>
<li>some visual effects</li>
</ul>
<p>Macroquad does not force any specific way to store data or game objects. Macroquad does have some embedded ways for organizing scenes and is friendly for any third-party ECS-like crates.</p>
<p>For Fish Game, we are going to use macroquad's scenes. </p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Player {
</span><span>    collider: Actor,
</span><span>    speed: Vec2,
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Player {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub const </span><span style="color:#0086b3;">JUMP_SPEED</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">f32 = -</span><span style="color:#0086b3;">700.0</span><span>;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub const </span><span style="color:#0086b3;">GRAVITY</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">f32 = </span><span style="color:#0086b3;">2000.0</span><span>;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub const </span><span style="color:#0086b3;">MOVE_SPEED</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">f32 = </span><span style="color:#0086b3;">300.0</span><span>;
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">new</span><span>() -&gt; Player {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> resources </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>storage::get_mut::&lt;Resources&gt;().</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>
</span><span>        Player {
</span><span>            collider: resources.physics.</span><span style="color:#62a35c;">add_actor</span><span>(</span><span style="color:#62a35c;">vec2</span><span>(</span><span style="color:#0086b3;">200.0</span><span>, </span><span style="color:#0086b3;">100.0</span><span>), </span><span style="color:#0086b3;">36</span><span>, </span><span style="color:#0086b3;">66</span><span>),
</span><span>            speed: </span><span style="color:#62a35c;">vec2</span><span>(</span><span style="color:#0086b3;">0.</span><span>, </span><span style="color:#0086b3;">0.</span><span>),
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Node </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Player {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">draw</span><span>(node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> resources </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>storage::get_mut::&lt;Resources&gt;().</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> pos </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> resources.physics.</span><span style="color:#62a35c;">actor_pos</span><span>(node.collider);
</span><span>
</span><span>        </span><span style="color:#62a35c;">draw_texture_ex</span><span>(
</span><span>            resources.whale,
</span><span>            pos.x </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">20.</span><span>,
</span><span>            pos.y,
</span><span>            </span><span style="color:#0086b3;">WHITE</span><span>,
</span><span>            DrawTextureParams {
</span><span>                source: </span><span style="color:#0086b3;">Some</span><span>(Rect::new(</span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#0086b3;">0.0</span><span>, </span><span style="color:#0086b3;">76.</span><span>, </span><span style="color:#0086b3;">66.</span><span>)),
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">Default</span><span>::default()
</span><span>            },
</span><span>        );
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">update</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span>node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> world </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut </span><span>storage::get_mut::&lt;Resources&gt;().</span><span style="color:#62a35c;">unwrap</span><span>().physics;
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> pos </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> world.</span><span style="color:#62a35c;">actor_pos</span><span>(node.collider);
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> on_ground </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> world.</span><span style="color:#62a35c;">collide_check</span><span>(node.collider, pos </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#62a35c;">vec2</span><span>(</span><span style="color:#0086b3;">0.</span><span>, </span><span style="color:#0086b3;">1.</span><span>));
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> on_ground </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">false </span><span>{
</span><span>            node.speed.y </span><span style="font-weight:bold;color:#a71d5d;">+= Self</span><span>::</span><span style="color:#0086b3;">GRAVITY </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#62a35c;">get_frame_time</span><span>();
</span><span>        }
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">is_key_down</span><span>(KeyCode::Right) {
</span><span>            node.speed.x </span><span style="font-weight:bold;color:#a71d5d;">= Self</span><span>::</span><span style="color:#0086b3;">MOVE_SPEED</span><span>;
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else if </span><span style="color:#62a35c;">is_key_down</span><span>(KeyCode::Left) {
</span><span>            node.speed.x </span><span style="font-weight:bold;color:#a71d5d;">= -Self</span><span>::</span><span style="color:#0086b3;">MOVE_SPEED</span><span>;
</span><span>        } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span>{
</span><span>            node.speed.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0.</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">is_key_pressed</span><span>(KeyCode::Space) {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> on_ground {
</span><span>                node.speed.y </span><span style="font-weight:bold;color:#a71d5d;">= Self</span><span>::</span><span style="color:#0086b3;">JUMP_SPEED</span><span>;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        world.</span><span style="color:#62a35c;">move_h</span><span>(node.collider, node.speed.x </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#62a35c;">get_frame_time</span><span>());
</span><span>        world.</span><span style="color:#62a35c;">move_v</span><span>(node.collider, node.speed.y </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#62a35c;">get_frame_time</span><span>());
</span><span>    }
</span><span>}
</span><span>
</span><span>async </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span>() {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>    </span><span style="font-style:italic;color:#969896;">// this is it, now it will get its draw/update calls 
</span><span>    scene::add_node(Player::new());
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>}
</span></code></pre>
<p><a href="https://gist.github.com/not-fl3/a98d9f9e37a01be8bc2f0d246164b8bb">Full source code</a>.</p>
<p>It may not look like a big improvement over the previous approach, but scenes allow building complicated node relationships and applying iteration strategies over scene nodes. We are going to use it a lot more in the upcoming sections.</p>
<h1 id="networking-with-nakama"><a class="zola-anchor" href="#networking-with-nakama" aria-label="Anchor link for: networking-with-nakama">ðŸ”—</a>Networking with Nakama</h1>
<p>The <a href="https://github.com/heroiclabs/nakama-rs/">&quot;nakama-rs&quot;</a> crate is a pure Rust implementation of the Nakama protocol.</p>
<p>It allows working with Nakama in three different styles. </p>
<ul>
<li>nakama-rs can produce raw data with either HTTP or WebSocket requests, but leaves the networking implementation for the user.</li>
<li>nakama-rs can make Rest/WebSocket calls with that raw data, but with a very low-level interface over requests.</li>
<li>Very high-level stateful client, which hides implementation details completely.</li>
</ul>
<p>For Fish Game, we are going to use that high-level client.  That client works as a giant state machine - the user makes non-blocking calls, and the client may change some internal state based on those calls.
Than in the main loop game pull changes from the ApiClient and may react accordingly.</p>
<h2 id="connecting-to-nakama"><a class="zola-anchor" href="#connecting-to-nakama" aria-label="Anchor link for: connecting-to-nakama">ðŸ”—</a>Connecting to Nakama</h2>
<p>nakama-rs' ApiClient will be used as a singleton. Once a global object is created, it is persisted throughout the game lifetime and is globally accessible.</p>
<p>In macroquad, we can use the node system for this. It will still be a singleton, but the access and relationship graph with our new Nakama node will be easily traceable and visible.</p>
<p>So we will create a scene node with ApiClient and  pass a reference to this node to all nodes communicating with Nakama.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>api_client: ApiClient,
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">new</span><span>(key: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span>, server: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span>, port: </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span>, protocol: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span>) -&gt; Nakama {
</span><span>        Nakama {
</span><span>            api_client: ApiClient::new(key, server, port, protocol),
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>scene::Node </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">ready</span><span>(node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-style:italic;color:#969896;">// Once created, nakama node should never be deleted.
</span><span>        </span><span style="font-style:italic;color:#969896;">// The persist() call will make nakama node a singleton,
</span><span>        </span><span style="font-style:italic;color:#969896;">// alive during all scene reloads.
</span><span>        node.</span><span style="color:#62a35c;">persist</span><span>();
</span><span>    }
</span><span>
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">update</span><span>(node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-style:italic;color:#969896;">// api_client should be &quot;ticked&quot; once per frame
</span><span>        self.api_client.</span><span style="color:#62a35c;">tick</span><span>();
</span><span>    }
</span><span>}
</span><span>
</span><span>async </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span>() {
</span><span>    </span><span style="font-style:italic;color:#969896;">// now the first node in the scene will be a nakama node
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> nakama </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>scene::add_node(nodes::Nakama::new(
</span><span>        credentials::</span><span style="color:#0086b3;">NAKAMA_KEY</span><span>,
</span><span>        credentials::</span><span style="color:#0086b3;">NAKAMA_SERVER</span><span>,
</span><span>        credentials::</span><span style="color:#0086b3;">NAKAMA_PORT</span><span>,
</span><span>        credentials::</span><span style="color:#0086b3;">NAKAMA_PROTOCOL</span><span>,
</span><span>    ));
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span>} 
</span></code></pre>
<h2 id="authentication-and-registration"><a class="zola-anchor" href="#authentication-and-registration" aria-label="Anchor link for: authentication-and-registration">ðŸ”—</a>Authentication and registration</h2>
<p>Macroquad uses the immediate mode gui concept for UI. Here we will skip GUI style setup (it may be found <a href="https://github.com/heroiclabs/fishgame-macroquad/blob/master/src/gui.rs#L36">here</a>), and we will proceed to the UI logic instead.</p>
<img src="/fishgame_tutorial/login.png"  width="100%"/>
<p>Most UI windows interacting with Nakama are built in the same way:</p>
<ul>
<li>get Nakama node</li>
<li>check if some operation is in progress, and if it is - show loading UI</li>
<li>check if there is some error to show</li>
<li>check if Nakama finished the required operation and can proceed to the next window</li>
<li>draw all input elements and on some button press - make a Nakama request</li>
</ul>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> email </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span>::new();
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> password </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span>::new();
</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> nakama </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>scene::get_node(nakama).</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>            
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> nakama.api_client.</span><span style="color:#62a35c;">in_progress</span><span>() {
</span><span>        </span><span style="color:#62a35c;">in_progress_gui</span><span>();
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return</span><span>;
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#0086b3;">Some</span><span>(error) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> nakama.api_client.</span><span style="color:#62a35c;">error</span><span>().</span><span style="color:#62a35c;">as_deref</span><span>() {
</span><span>        ui.</span><span style="color:#62a35c;">label</span><span>(</span><span style="color:#0086b3;">None</span><span>, error);
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> nakama.api_client.</span><span style="color:#62a35c;">authenticated</span><span>() {
</span><span>        </span><span style="font-style:italic;color:#969896;">// done with authentication, proceeding to matchmaking
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span>Scene::MatchmakingLobby;
</span><span>    }
</span><span>
</span><span>    widgets::InputText::new(hash!())
</span><span>        .</span><span style="color:#62a35c;">label</span><span>(</span><span style="color:#183691;">&quot;Email&quot;</span><span>)
</span><span>        .</span><span style="color:#62a35c;">ui</span><span>(ui, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span> email);
</span><span>
</span><span>    widgets::InputText::new(hash!())
</span><span>        .</span><span style="color:#62a35c;">password</span><span>(</span><span style="color:#0086b3;">true</span><span>)
</span><span>        .</span><span style="color:#62a35c;">label</span><span>(</span><span style="color:#183691;">&quot;Password&quot;</span><span>)
</span><span>        .</span><span style="color:#62a35c;">ui</span><span>(ui, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span> password);
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> ui.</span><span style="color:#62a35c;">button</span><span>(</span><span style="color:#0086b3;">None</span><span>, </span><span style="color:#183691;">&quot;Login&quot;</span><span>) {
</span><span>        nakama.api_client.</span><span style="color:#62a35c;">authenticate</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>email, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>password);
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#62a35c;">next_frame</span><span>().await;
</span><span>}
</span></code></pre>
<h2 id="real-time-multiplayer"><a class="zola-anchor" href="#real-time-multiplayer" aria-label="Anchor link for: real-time-multiplayer">ðŸ”—</a>Real-time multiplayer</h2>
<p><em>The real-time multiplayer engine makes it easy for users to set up and join matches where they can rapidly exchange data with opponents.
Any user can participate in matches with other users. Users can create, join, and leave matches with messages sent from clients. A match exists on the server until its last participant has left.
Any data sent through a match is immediately routed to all other participants. The matches are kept in memory and can be persisted as needed.</em>
<a href="https://heroiclabs.com/docs/gameplay-multiplayer-realtime/">source</a></p>
<p>Match window code is very similar to the authentication window, as well as all other windows in Fish Game:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">loop </span><span>{
</span><span>    </span><span style="font-style:italic;color:#969896;">// check if nakama is in progress 
</span><span>    </span><span style="font-style:italic;color:#969896;">// check if nakama has errors
</span><span>    </span><span style="font-style:italic;color:#969896;">// check if nakama finished and we can return
</span><span>    </span><span style="font-style:italic;color:#969896;">// draw some input widgets and maybe make nakama request
</span><span>}
</span></code></pre>
<p>Now let's focus on how Nakama's real-time matches work.</p>
<img src="/fishgame_tutorial/matchmaker.png"  width="100%"/>
<p>To create a match:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>nakama.</span><span style="color:#62a35c;">socket_create_match</span><span>();
</span></code></pre>
<p>This will start a process that on success will give some id in <code>nakama.match_id()</code>. </p>
<p>This ID may be shared to friends to join this exact match later: </p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>nakama.</span><span style="color:#62a35c;">socket_join_match_by_id</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>match_id);
</span></code></pre>
<p>We have two problems here: </p>
<ul>
<li>Match discoverability.
Sharing a match id with a friend works for private games, but we need a better solution for public games.
This will be addressed in the <a href="https://macroquad.rs/articles/fish-tutorial/#Matchmaker">Matchmaker</a> section.</li>
<li>Nakama considers a match started right after the <code>create_match</code> call, and anyone can join at any moment. While the rules of Fish Game won't let players join in the middle, and the game starts only when all of the players have pressed the â€œreadyâ€ button.
This will be addressed in the <a href="https://macroquad.rs/articles/fish-tutorial/#Ready-window">Ready window</a> section.</li>
</ul>
<h2 id="matchmaker"><a class="zola-anchor" href="#matchmaker" aria-label="Anchor link for: matchmaker">ðŸ”—</a>Matchmaker</h2>
<p>You can use the Matchmaker to find other players. It is possible to match them using properties and a query that specifies the values the other players' properties should hold. In <code>nakama-rs</code> the Matchmaker is a <code>struct</code> and can be created using <code>Matchmaker::new()</code>. There are two types of properties, string properties and numeric properties that can be added with <code>matchmaker.add_string_property(&quot;name&quot;, &quot;value&quot;)</code> and <code>matchmaker.add_numeric_property(&quot;rank&quot;, 1000.0)</code> respectively. Names of properties should be unique across both types.</p>
<p>The query is a space-separated string using the <a href="http://blevesearch.com/docs/Query-String-Query/">Bleve Query-String-Query Syntax</a>. It is possible to add queries manually using <code>matchmaker.add_query_item(&quot;properties.region:Europe&quot;)</code> but <code>nakama-rs</code> provides a helper to construct the query string using the builder pattern. For now, terms, numeric ranges, required, optional and exclusion are supported. See <a href="https://github.com/heroiclabs/nakama-rs/blob/master/examples/matchmaker.rs">examples/matchmaker.rs</a> for more examples.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#969896;">// By default query items are optional. The Matchmaker will prefer
</span><span style="font-style:italic;color:#969896;">// players holding the value, but will also match players without it.
</span><span style="font-style:italic;color:#969896;">// Prefer players from Europe.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> query_item </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>QueryItemBuilder::new(</span><span style="color:#183691;">&quot;region&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">term</span><span>(</span><span style="color:#183691;">&quot;Europe&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">build</span><span>();
</span><span>    
</span><span style="font-style:italic;color:#969896;">// Only match with players from Europe    
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> query_item </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>QueryItemBuilder::new(</span><span style="color:#183691;">&quot;region&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">term</span><span>(</span><span style="color:#183691;">&quot;Europe&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">required</span><span>()
</span><span>    .</span><span style="color:#62a35c;">build</span><span>();   
</span><span>    
</span><span style="font-style:italic;color:#969896;">// Only match with players not from Europe
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> query_item </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>QueryItemBuilder::new(</span><span style="color:#183691;">&quot;region&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">term</span><span>(</span><span style="color:#183691;">&quot;Europe&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">excluded</span><span>()
</span><span>    .</span><span style="color:#62a35c;">build</span><span>();
</span><span>    
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span> query_item </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>QueryItemBuilder::new(</span><span style="color:#183691;">&quot;rank&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">lt</span><span>(</span><span style="color:#0086b3;">10</span><span>) </span><span style="font-style:italic;color:#969896;">// or .gt(10), .leq(10) and .geq(10)
</span><span>    .</span><span style="color:#62a35c;">build</span><span>();
</span></code></pre>
<p>In addition, it is possible to specify the minimum and the maximum number of players using <code>matchmaker.min(2)</code> and <code>matchmaker.max(100)</code>. The default values are 2 and 100, respectively.</p>
<img src="/fishgame_tutorial/matchmaker2.png"  width="100%"/>
<p>Fish Game only specifies one property called <code>&quot;engine&quot;</code> with the value <code>macroquad_engine</code>. The query only specifies that we also match players holding the same value for that property, allowing us to avoid matchmaking players running a different game on the same Nakama server.</p>
<p>The full matchmaker setup can be seen below:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>widgets::InputText::new(hash!())
</span><span>    .</span><span style="color:#62a35c;">ratio</span><span>(</span><span style="color:#0086b3;">1. </span><span style="font-weight:bold;color:#a71d5d;">/ </span><span style="color:#0086b3;">4.</span><span>)
</span><span>    .</span><span style="color:#62a35c;">filter_numbers</span><span>()
</span><span>    .</span><span style="color:#62a35c;">label</span><span>(</span><span style="color:#183691;">&quot;Minimum players&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">ui</span><span>(ui, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span> minimum_players);
</span><span>
</span><span>widgets::InputText::new(hash!())
</span><span>    .</span><span style="color:#62a35c;">ratio</span><span>(</span><span style="color:#0086b3;">1. </span><span style="font-weight:bold;color:#a71d5d;">/ </span><span style="color:#0086b3;">4.</span><span>)
</span><span>    .</span><span style="color:#62a35c;">filter_numbers</span><span>()
</span><span>    .</span><span style="color:#62a35c;">label</span><span>(</span><span style="color:#183691;">&quot;Maximum players&quot;</span><span>)
</span><span>    .</span><span style="color:#62a35c;">ui</span><span>(ui, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span> maximum_players);
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">if</span><span> ui.</span><span style="color:#62a35c;">button</span><span>(</span><span style="color:#0086b3;">None</span><span>, </span><span style="color:#183691;">&quot;Start matchmaking&quot;</span><span>) {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> matchmaker </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>Matchmaker::new();
</span><span>
</span><span>    matchmaker
</span><span>        .</span><span style="color:#62a35c;">min</span><span>(minimum_players.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">u32</span><span>&gt;().</span><span style="color:#62a35c;">unwrap</span><span>())
</span><span>        .</span><span style="color:#62a35c;">max</span><span>(maximum_players.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">u32</span><span>&gt;().</span><span style="color:#62a35c;">unwrap</span><span>())
</span><span>        .</span><span style="color:#62a35c;">add_string_property</span><span>(</span><span style="color:#183691;">&quot;engine&quot;</span><span>, </span><span style="color:#183691;">&quot;macroquad_matchmaking&quot;</span><span>)
</span><span>        .</span><span style="color:#62a35c;">add_query_item</span><span>(
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>QueryItemBuilder::new(</span><span style="color:#183691;">&quot;engine&quot;</span><span>)
</span><span>                .</span><span style="color:#62a35c;">required</span><span>()
</span><span>                .</span><span style="color:#62a35c;">term</span><span>(</span><span style="color:#183691;">&quot;macroquad_matchmaking&quot;</span><span>)
</span><span>                .</span><span style="color:#62a35c;">build</span><span>(),
</span><span>        );
</span><span>
</span><span>    nakama.api_client.</span><span style="color:#62a35c;">socket_add_matchmaker</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>matchmaker);
</span><span>
</span><span>    next_scene </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span>(Scene::WaitingForMatchmaking { private: </span><span style="color:#0086b3;">false </span><span>});
</span><span>);
</span></code></pre>
<p>You can add the Matchmaker by calling <code>nakama.socket_add_matchmaker(&amp;matchmaker)</code>, adding the user to the server's matchmaking pool. The user will stay in the pool until matched as long as they are online or until you remove them manually. It is possible to add multiple matchmakers with different queries simultaneously to look for different types of matches.</p>
<p>When the server matches the user, the ApiClient will handle the event and set <code>nakama.matchmaker_token</code> to <code>Some(token)</code>. The token is a short-lived entry ticket that you can use to join a match with the other matched players by calling <code>nakama.socket_join_match_by_token(token)</code>. The server creates the match as soon as the first player tries to join it and sends an event once the player joined successfully. In the client, <code>nakama.match_id()</code> will then contain a value. It is now possible to send match data between players.</p>
<p>For additional details, check out the <a href="https://heroiclabs.com/docs/gameplay-matchmaker">Matchmaker documentation</a>.</p>
<h2 id="exchanging-messages"><a class="zola-anchor" href="#exchanging-messages" aria-label="Anchor link for: exchanging-messages">ðŸ”—</a>Exchanging messages</h2>
<p>nakama-rs'<code>ApiClient</code> provides two API calls to communicate between each other: </p>
<ul>
<li><code>fn socket_send&lt;T: SerBin&gt;(&amp;self, opcode: u32, data: T)</code>
<code>socket_send</code> will binary serialize given message and broadcast it to each player in the room. Opcode here acts as a tag or discriminant in rust <a href="https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html">enum</a> - a small descriptor specifiyng what kind of data is being sent.</li>
<li><code>fn try_recv(&amp;self) -&gt; Option&lt;Event&gt;</code>
<code>try_recv</code> will give an Event if someone sent a message or joined/left match since last <code>try_recv</code> call.</li>
</ul>
<p>A convenient Rust representation of an <code>opcode</code>/<code>data</code> pair may look like this:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">mod </span><span>message {
</span><span>    #[derive(Debug, Clone, SerBin, DeBin, PartialEq)]
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>State {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>pos: (</span><span style="font-weight:bold;color:#a71d5d;">u16</span><span>, </span><span style="font-weight:bold;color:#a71d5d;">u16</span><span>),
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>facing: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>,
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>State {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub const </span><span style="color:#0086b3;">OPCODE</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">1</span><span>;
</span><span>    }
</span><span>
</span><span>    #[derive(Debug, Clone, SerBin, DeBin, PartialEq)]
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>Damage {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>target: String,
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>direction: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span>,
</span><span>    }
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Damage {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub const </span><span style="color:#0086b3;">OPCODE</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">2</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>Then, in order to send some message:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>nakama.api_client.</span><span style="color:#62a35c;">send</span><span>(Damage::</span><span style="color:#0086b3;">OPCODE</span><span>, Damage {
</span><span>    target: target.network_id,
</span><span>    direction: </span><span style="color:#0086b3;">false
</span><span>});
</span></code></pre>
<p>To recieve such a message on other client: </p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span>(event) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> nakama.</span><span style="color:#62a35c;">try_recv</span><span>() {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">..
</span><span>}
</span></code></pre>
<p>Event may be either a message from other client or a system even like joined/leaved player. This will be explained in details in <a href="https://macroquad.rs/articles/fish-tutorial/#Player-state-synchronization">Player state syncronization</a> section.</p>
<h2 id="player-state-synchronization"><a class="zola-anchor" href="#player-state-synchronization" aria-label="Anchor link for: player-state-synchronization">ðŸ”—</a>Player state synchronization</h2>
<p>Fish Game uses a relayed network synchronization model. Each player simulates its physics and sends its state to other players.</p>
<p>One of the players is called &quot;host&quot; and is responsible for global events and conflict resolution.</p>
<p>Nakama node from previous chapters:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">impl </span><span>scene::Node </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">update</span><span>(node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        node.api_client.</span><span style="color:#62a35c;">tick</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now it will also take responsibility for state synchronization. </p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">impl </span><span>scene::Node </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">update</span><span>(node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-style:italic;color:#969896;">// send our own player state to all the other players
</span><span>        {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> player </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>scene::find_node_by_type::&lt;Player&gt;().</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> state </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>message::State {
</span><span>                pos: (player.pos.x </span><span style="font-weight:bold;color:#a71d5d;">as u16</span><span>, player.pos.y </span><span style="font-weight:bold;color:#a71d5d;">as u16</span><span>), 
</span><span>                facing: player.</span><span style="color:#62a35c;">facing</span><span>(),
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">..
</span><span>            };
</span><span>            node.api_client.</span><span style="color:#62a35c;">socket_send</span><span>(message::State::</span><span style="color:#0086b3;">OPCODE</span><span>, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>message::State(state.</span><span style="color:#0086b3;">0</span><span>));
</span><span>        }
</span><span>        node.api_client.</span><span style="color:#62a35c;">tick</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p>In the final game code, the <code>State</code> structure is slightly more <a href="https://github.com/heroiclabs/fishgame-macroquad/blob/master/src/nodes/nakama/nakama_realtime_game.rs#L67">optimized</a>.</p>
<p>Also, in the real game, network fps are different from the rendering fps - with networking lag sending state 60 times per second is too much, and ~15-20 should be enough. Fish Game works on 15.
But the idea is the same - The <code>Nakama</code> node packs all the important parts of the player state and sends it over the network to all the other players in the room. </p>
<p>Next step - receive other players' data and draw other players.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Nakama {
</span><span>    </span><span style="font-style:italic;color:#969896;">// now Nakama node is keeping track on all remote players in the scene
</span><span>    </span><span style="font-style:italic;color:#969896;">// key here is session_id from nakama presence - the always unique player identifier
</span><span>    remote_players: HashMap&lt;</span><span style="color:#0086b3;">String</span><span>, Handle&lt;RemotePlayer&gt;&gt;
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>scene::Node </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">update</span><span>(node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-style:italic;color:#969896;">// send our own player state to all the other players
</span><span>        {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">..
</span><span>        }
</span><span>        
</span><span>        </span><span style="font-style:italic;color:#969896;">// receive other players updates
</span><span>        {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span>(event) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> nakama.</span><span style="color:#62a35c;">try_recv</span><span>() {
</span><span>                </span><span style="font-style:italic;color:#969896;">// proceed event and modify the scene somehow
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">..
</span><span>            }
</span><span>        }
</span><span>        node.api_client.</span><span style="color:#62a35c;">tick</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p>That is the bare-bones implementation - for each frame, we receive all the Nakama events and apply changes to the scene. 
We need to have a list of <code>remote_players</code> to track the scene nodes of remote players and add/remove players on game joins or leaves. And we need to apply the received messages to those remote players.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">match</span><span> event {
</span><span>    </span><span style="font-style:italic;color:#969896;">// add or remove RemotePlayer node
</span><span>    Event::::Presence { joins, leaves } </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span>{
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> joined </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> joins {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> joined_id </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> join.session_id;
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> username </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> join.username;
</span><span>
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> remote_player </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>RemotePlayer::new(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>username, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>joined);
</span><span>             self.remote_players.</span><span style="color:#62a35c;">insert</span><span>(
</span><span>                joined.</span><span style="color:#62a35c;">clone</span><span>(),
</span><span>                scene::add_node(remote_player),
</span><span>            );
</span><span>
</span><span>        }
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> leaver </span><span style="font-weight:bold;color:#a71d5d;">in</span><span> leaves {
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> other </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>self.remote_players.</span><span style="color:#62a35c;">remove</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>leaver).</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> leaver </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>scene::get_node::&lt;RemotePlayer&gt;(leaver).</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>            other.</span><span style="color:#62a35c;">delete</span><span>();
</span><span>        }
</span><span>
</span><span>    }
</span></code></pre>
<p>This will keep the list of active remote players accurate, and for each, we will have a RemotePlayer node.</p>
<p>The RemotePlayer node may be very similar to the Player node but with very different logic.</p>
<p>Then continue the event handling <code>match</code> to deal with a data message:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#969896;">// received opcode/data pair
</span><span>Event::MatchData {
</span><span>    user_id,
</span><span>    opcode,
</span><span>    data,
</span><span>} </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#0086b3;">Some</span><span>(remote_player) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>self.remote_players.</span><span style="color:#62a35c;">get</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>user_id) {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span> remote_player </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>scene::get_node(</span><span style="font-weight:bold;color:#a71d5d;">*</span><span>remote_player).</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span> opcode </span><span style="font-weight:bold;color:#a71d5d;">as i32 </span><span>{
</span><span>            message::State::</span><span style="color:#0086b3;">OPCODE </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span>{
</span><span>                </span><span style="font-style:italic;color:#969896;">// deserialize message according to opcode
</span><span>                </span><span style="font-weight:bold;color:#a71d5d;">let </span><span>message::State(data) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>DeBin::deserialize_bin(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>data).</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>
</span><span>                </span><span style="font-style:italic;color:#969896;">// and apply message data to the remote player node
</span><span>                remote_player.</span><span style="color:#62a35c;">set_pos</span><span>(data.pos.</span><span style="color:#0086b3;">0 </span><span style="font-weight:bold;color:#a71d5d;">as f32</span><span>, data.pos.</span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">as f32</span><span>);
</span><span>                remote_player.</span><span style="color:#62a35c;">set_facing</span><span>(data.facing);
</span><span>            }
</span><span>        }
</span><span>    }
</span><span>} 
</span></code></pre>
<p><a href="https://github.com/heroiclabs/fishgame-macroquad/blob/master/src/nodes/nakama/nakama_realtime_game.rs"><em>src/nodes/nakama/nakama_realtime_game.rs</em></a></p>
<h2 id="a-note-about-network-performance"><a class="zola-anchor" href="#a-note-about-network-performance" aria-label="Anchor link for: a-note-about-network-performance">ðŸ”—</a>A note about network performance</h2>
<p>While Fish Game has good enough network performance to be fully functional, it is kept intentionally simplistic for demonstration purposes.</p>
<p>Nakamaâ€™s real-time Multiplayer API sends data over WebSockets, which means TCP. TCP is reliable (you know if the message you sent arrived or not), but itâ€™s slower. For an in-depth explanation about the trade-offs between TCP and UDP, see <a href="https://heroiclabs.com/docs/expert-tcp-udp/">Choosing TCP or UDP: a guide for game developers</a>.</p>
<p>Fast-paced games commonly use UDP to send synchronization information: itâ€™s unreliable (your message can get lost) but faster. Using unreliable UDP would allow for some network optimizations that we canâ€™t do here. For example, with some kinds of game states, only the most recent message is valid (all older messages are immediately invalid once a newer one arrives), so we could use the faster UDP packets.
Itâ€™s OK if some get lost, we'd just take the newest one that arrives.</p>
<p>This game is fast-paced enough that it ideally should be using â€œinput prediction and rollbackâ€ rather than â€œinput prediction and correctionâ€. When using rollback, rather than applying the corrections you received to the current state of the game, you roll back the local game state to the time when the remote state was generated, apply it, and then roll the game state forward to the current time. This can help eliminate lag and avoid situations where one player sees themselves hitting another player, but it doesnâ€™t  register as a hit. However, rollback is a lot more complicated to implement than correction. Fish Game has enough in common with arcade-style Fighting Games that the most optimal networking technique for it might be the <a href="https://github.com/pond3r/ggpo">GGPO</a> technique.</p>
<p>This would merit further investigation if this was a commercial game.</p>
<h2 id="global-events-and-conflicts-resolution"><a class="zola-anchor" href="#global-events-and-conflicts-resolution" aria-label="Anchor link for: global-events-and-conflicts-resolution">ðŸ”—</a>Global events and conflicts resolution</h2>
<p>In Fish Game, we have some global events. Good example: Spawn process of pickable weapon.</p>
<p>There are two ways to simulate such a process:</p>
<ul>
<li>Make it deterministic and simulate it on each client.</li>
<li>Call one of the clients â€œhostâ€. Simulate such an event only on that client and this client will tell everyone else which weapon spawned where.</li>
</ul>
<p>With the deterministic approach, we are going to have a problem with conflicts - if two players correctly simulated that they picked the weapon at the very same time, who is right? </p>
<p>With the &quot;host&quot; approach it is way easier - the host may be responsible for such decisions.</p>
<p>While all the players have unique IDs and everyone knows each other's ID, we can just sort the list of <code>remote_players</code> IDs and whoever's first is the host. </p>
<p>Now we can create a special node, <code>GlobalEvents</code>:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>GlobalEvents {
</span><span>    nakama: NodeHandle&lt;Nakama&gt;,
</span><span>    last_spawn_time: </span><span style="font-weight:bold;color:#a71d5d;">f32</span><span>,
</span><span>}
</span><span>
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>scene::Node </span><span style="font-weight:bold;color:#a71d5d;">for </span><span>GlobalEvents {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">update</span><span>(</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span>node: RefMut&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self</span><span>&gt;) {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> nakama </span><span style="font-weight:bold;color:#a71d5d;">= </span><span>scene::get_node(node.nakama).</span><span style="color:#62a35c;">unwrap</span><span>();
</span><span>        
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span> nakama.</span><span style="color:#62a35c;">is_host</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">false </span><span>{
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">return</span><span>;
</span><span>        }
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">get_time</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">-</span><span> node.last_spawn_time </span><span style="font-weight:bold;color:#a71d5d;">&gt;= Self</span><span>::</span><span style="color:#0086b3;">SPAWN_INTERVAL </span><span style="font-weight:bold;color:#a71d5d;">as _
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">&amp;&amp;</span><span> node.spawned_items.</span><span style="color:#62a35c;">len</span><span>() </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">3 </span><span>{
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> new_item_pos </span><span style="font-weight:bold;color:#a71d5d;">= ..</span><span>;
</span><span>            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span> new_item_type </span><span style="font-weight:bold;color:#a71d5d;">= ..</span><span>;
</span><span>            
</span><span>            nakama.</span><span style="color:#62a35c;">spawn_item</span><span>(new_item_pos, new_item_type);    
</span><span>        }
</span><span>        
</span><span>    }
</span><span>}
</span></code></pre>
<p><a href="https://github.com/heroiclabs/fishgame-macroquad/blob/master/src/nodes/global_events.rs"><em>src/nodes/global_events.rs</em></a></p>
<h2 id="ready-window"><a class="zola-anchor" href="#ready-window" aria-label="Anchor link for: ready-window">ðŸ”—</a>Ready window</h2>
<img src="/fishgame_tutorial/ready.png"  width="100%"/>
<p>One of our unsolved problems: in Fish Game the game starts only when all the players joined the match, can see each other and has opted in as ready. </p>
<p>After this point, it is impossible to join a match and only one last standing fish will win.</p>
<p>All this logic may be implemented on top of Nakama's messages.</p>
<p>We can add a flag to our Nakama node:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">struct </span><span>Nakama {
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>api_client: ApiClient,
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span>game_started: </span><span style="font-weight:bold;color:#a71d5d;">bool 
</span><span>}
</span></code></pre>
<p>And introduce a special message:</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">mod </span><span>messages {
</span><span>    #[derive(Debug, Clone, SerBin, DeBin, PartialEq)]
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span>Ready;
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">impl </span><span>Ready {
</span><span>        </span><span style="font-weight:bold;color:#a71d5d;">pub const </span><span style="color:#0086b3;">OPCODE</span><span>: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">6</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p>Now it is the game's responsibility to figure when to start a match. In Fish Game rules are quite simple - before everyone pushed &quot;Ready&quot; and the host confirmed by pushing &quot;Start game&quot; - no loot is spawning and noone is allowed to move. Implementation is in <a href="https://github.com/heroiclabs/fishgame-macroquad/blob/master/src/nodes/nakama/nakama_realtime_game.rs">nakama node</a></p>
<p>But this logic may be totally different depending on game design, and the goal of this little chapter - demonstrate where nakama's area of responsibility in the matchmaker/match logic ends and game should roll its own logic. </p>
<h2 id="leaderboards"><a class="zola-anchor" href="#leaderboards" aria-label="Anchor link for: leaderboards">ðŸ”—</a>Leaderboards</h2>
<p>Thereâ€™s one last Nakama feature weâ€™re going to look at before ending this tutorial: Leaderboards.</p>
<p>Leaderboards need to be created on the server before your game can write data to them. This is done in Fish Game by adding a small server-side Lua module in <code>nakama/data/modules/fish_game.lua</code>:</p>
<pre data-lang="lua" style="background-color:#ffffff;color:#323232;" class="language-lua "><code class="language-lua" data-lang="lua"><span style="font-weight:bold;color:#a71d5d;">local </span><span>nk </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">require</span><span>(</span><span style="color:#183691;">&quot;nakama&quot;</span><span>)
</span><span>
</span><span>nk.run_once(</span><span style="font-weight:bold;color:#a71d5d;">function</span><span>(context)
</span><span>  nk.leaderboard_create(</span><span style="color:#183691;">&quot;fish_game_wins&quot;</span><span>, </span><span style="color:#0086b3;">false</span><span>, </span><span style="color:#183691;">&quot;desc&quot;</span><span>, </span><span style="color:#183691;">&quot;incr&quot;</span><span>)
</span><span style="font-weight:bold;color:#a71d5d;">end</span><span>)
</span></code></pre>
<p>This runs on the Nakama server at startup and creates a leaderboard called â€œfishgamewinsâ€, which weâ€™re going to use to track the total number of wins that each player has gotten.</p>
<p>Itâ€™s a non-authoritative leaderboard (the <code>false</code> in the 2nd argument), which means that the game clients can modify the leaderboard themselves, rather than requiring server-side logic to do it. Itâ€™s sorted in descending order (the &quot;desc&quot; in the 3rd argument) and is updated by incrementing the score (the &quot;incr&quot; in the 4th argument).</p>
<p>Note: Nakama modules can be written in Lua, Go or (in Nakama 3) JavaScript.</p>
<h2 id="posting-results-to-the-leaderboard"><a class="zola-anchor" href="#posting-results-to-the-leaderboard" aria-label="Anchor link for: posting-results-to-the-leaderboard">ðŸ”—</a>Posting results to the leaderboard</h2>
<img src="/fishgame_tutorial/back_to_lobby.png"  width="100%"/>
<p>When only one fish is alive and the game has ended, the winner may update the leaderboard record.</p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>nakama.api_client.</span><span style="color:#62a35c;">write_leaderboard_record</span><span>(</span><span style="color:#183691;">&quot;fish_game_wins&quot;</span><span>, </span><span style="color:#0086b3;">1</span><span>)
</span></code></pre>
<p>We may want to wait for the result status to display some error and retry if we got a network error.</p>
<h2 id="accessing-the-leaderboard"><a class="zola-anchor" href="#accessing-the-leaderboard" aria-label="Anchor link for: accessing-the-leaderboard">ðŸ”—</a>Accessing the leaderboard</h2>
<img src="/fishgame_tutorial/leaderboard.png"  width="100%"/>
<p>The leaderboard window is not much different from the authentication/matchmaking window.</p>
<p>First, make the Nakama request: </p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span>nakama.api_client.</span><span style="color:#62a35c;">list_leaderboard_records</span><span>(</span><span style="color:#183691;">&quot;fish_game_wins&quot;</span><span>)
</span></code></pre>
<p>And then on success we will have something in <code>api_client.leaderboard_records</code></p>
<pre data-lang="rust" style="background-color:#ffffff;color:#323232;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#0086b3;">Some</span><span>(leaderboard) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span> nakama
</span><span>    .api_client
</span><span>    .</span><span style="color:#62a35c;">leaderboard_records</span><span>(</span><span style="color:#183691;">&quot;fish_game_wins&quot;</span><span>)
</span><span>{
</span><span>    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span> record </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span>leaderboard.records {
</span><span>        ui.</span><span style="color:#62a35c;">label</span><span>(</span><span style="color:#0086b3;">None</span><span>, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span>format!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span>, record.username, record.score));
</span><span>    }
</span><span>}
</span></code></pre>

    </div>
  </div>
</div>



  
    
<footer class="ui inverted vertical footer segment" style="padding: 2em 0em; margin-top: 3em;">
	<div class="ui container" style="">
		<div class="ui stackable inverted divided equal height stackable grid">
			<div class="eight wide column">
                <h4 class="ui inverted header">Powered by</h4>
                <div class="ui inverted link list">
                    <a class="item" href="https://www.getzola.org/">Zola</a>
                    <a class="item" href="https://semantic-ui.com">Semantic UI</a>
                </div>
            </div>
            <div class="eight wide column">
                <h4 class="ui inverted header">Page source</h4>
                <div class="ui inverted link list">
                    <a class="item" href="https://github.com/optozorax/macroquad-examples/">macroquad-website</a>
                </div>
            </div>
		</div>
	</div>
</footer>

  

</body>
</html>
